https://gpufit.readthedocs.io/en/latest/introduction.html

Erstelle Felder für allgemeine Parameter der Probe wie Leitfähigkeit

Finde objektiven Parameter, um die Mittleren Abstände an die Bingröße
anzupassen (/binsize?)

C1_S1_W_MI_1/2/3 sind Standards zum reinen Flusswasser hinzugespiked.
Blanks1/2/3 sind Systemblanks: Reinstwasser
Die anderen Blanks sind mit Standards gespiked.

Subsetting-Schritt, in dem ein Bin erstellt wurde, wirkt sich nicht merklich auf seine Qualität aus

Nur positiv-modus

Standards (u.a.):
Name		Masse		RT(min)	RT(s)	Addukt
Diclofenac	324.0260	14.4	864	M + H+
Sulfamethoxazol	258.0845	7.53	451.8	M + H+
Metoprolol	275.2352	7.50	450	M + 2H+
Carbamazepin	245.1525	10.13	607.8	M + H+

Je nach Datensatz kann es sinnvoll sein, auch "halbe" Peaks, bei denen 
das Intensitätsprofil nach dem höchsten Wert abbricht, mit einzubeziehen

prüfe auf nicht-deterministische Ergebnisse des Zentroidierens

Prozessausgabe in logfile schreiben

Mehrere Datensätze (Replikate), mit einer von Standards eingegrenzten Region
-> Prüfe Verteilung von Rauschen und prüfe, inwiefern Binparameter bei der Zuordnung helfen

https://www.desmos.com/calculator/bvc5r0epxz

https://www.desmos.com/calculator/enj0s6h2la // besser

https://www.desmos.com/calculator/eetmv0obav // mit Orbitrap Beispiel

https://www.desmos.com/calculator/5vbn1h8eim // kombi-version

https://github.com/sgorsten/linalg

Skalieren über Intensität für Kurvenanpassung nicht sonderlich vielversprechend

C:\PROGRA~2\GnuWin32\bin\make.exe

Gibt es einen Zusammenhang zwischen Zentroidfehler und der Eigenschaft, 
nicht in einem Bin zu landen / Anfang Bzw. Ende eines Bins zu sein?

Config-Datei

https://www.agner.org/optimize/optimizing_cpp.pdf

prüfen, wie das Programm skaliert -> subdatensätze

https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0125108

https://link.springer.com/article/10.1007/s41060-021-00275-z#Sec2

großen Multistandard-Datensatz anfragen (bfg - Datenbank)

Bin Reassembly sollte erst nach Aufreinigung der zu großen Bins passieren, diese müssen aber 
    von der Rekonstruktion ausgeschlossen werden

Bin Recutting: Suche nach ungewöhnlichen Mustern, Quantifizierung über summary-Params

// Template for a matrix. The dimensions are decided at run time
// This template makes a matrix of arbitrary dimensions
// There is no bounds checking
template <typename T>
class Matrix {
public:
// constructor with number of rows and columns
Matrix(int rows, int columns) {
// save number of rows and columns
this->rows = rows;
this->columns = columns;
// allocate memory
p = new T[rows * columns];
if (p == 0) {
// .. error message here: allocation failed
}
else {
// initialize all elements to zero
for (int i = 0; i < rows * columns; i++) {
p[i] = 0;
}
}
}
// get number of rows
int nrows() const {
return rows;
}
// get number of columns
int ncols() const {
return columns;
}
// destructor
~Matrix() {
if (p) delete[] p; // free the memory
}
// Operator [] gives a pointer to row number r.
// A second [] with the column number gives a single element
T * operator[] (int r) {
// no bounds check
return p + r * columns;
}
protected:
int rows; // number of rows
int columns; // number of columns
T * p; // pointer to memory
};
105
// ...
// Example of use:
// Make a matrix of doubles with 8 rows and 10 columns
Matrix<double> mat(8,10);
// Put a value in row 3, column 5
mat[3][5] = 12.34;
// Print out the matrix
for (int r = 0; r < mat.nrows(); r++) {
for (int c = 0; c < mat.ncols(); c++) {
printf("%5.2f ", mat[r][c]);
}
printf("\n");
}