https://www.desmos.com/calculator/bvc5r0epxz

https://www.desmos.com/calculator/enj0s6h2la // besser

https://www.desmos.com/calculator/eetmv0obav // mit Orbitrap Beispiel

https://www.desmos.com/calculator/5vbn1h8eim // kombi-version

https://github.com/sgorsten/linalg

Skalieren über Intensität für Kurvenanpassung nicht sonderlich vielversprechend

C:\PROGRA~2\GnuWin32\bin\make.exe

valgrind für Speicherdeallokierung, address sanitiser zum Laufen bringen

Gibt es einen Zusammenhang zwischen Zentroidfehler und der Eigenschaft, nicht in einem Bin zu landen / Anfang Bzw. Ende eines Bins zu sein?
Config-Datei

https://www.agner.org/optimize/optimizing_cpp.pdf

prüfen, wie das Programm skaliert -> subdatensätze

gcc -Wall -Werror .\src\qalgorithms_qbin.cpp  

https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0125108

https://link.springer.com/article/10.1007/s41060-021-00275-z#Sec2

Der schlechteste mögliche DQS sinkt mit n, Beweis?

Wichtig: Binning ist nur ein Schritt, und sollte entsprechend auf gute Endergebnisse
hin optimiert werden

Mögliche Optimierung: Reduziere Datapoint auf mz, rt, pointer für bessere Cachenutzung

Vorgehen DQS: Arbeite mit empirischer Stabw * 1.128 für MID, MOD = maxdist(n) => genauere Bestimmung des Faktors, test auf Abhängigkeit von n

quantile function ist inverse der normalverteilung

gibt es ein MID > vcrit im Datensatz?

großen Multistandard-Datensatz anfragen

long doubles wieder entfernen

Korrelationen mit Anzahl fehlender scans?

Falsche DQS: Bin wurde von einem viel größeren abgetrennt, der critVal entsprechend reduziert hat.
    zeigen kein besonders auffälliges Verhalten Bzgl. subsetting-Schritt

pracma omp wird nicht standardmäßig vom compiler akzeptiert

Instead of returning a composite object, you may consider the following alternatives:
• Make the function a constructor for the object.
• Make the function modify an existing object rather than making a new one. The
existing object can be made available to the function through a pointer or reference,
or the function could be a member of the object's class.
• Make the function return a pointer or reference to a static object defined inside the
function. This is efficient, but risky. The returned pointer or reference is valid only
until the next time the function is called and the local object is overwritten, possibly in
a different thread. If you forget to make the local object static then it becomes invalid
as soon as the function returns.

Bin Reassembly: Kopiere alle relevanten Bins zu den Werten nicht genutzter Punkte und lass 
das Binning erneut durchlaufen
    Sollte insbesondere nach Aufreinigung der zu großen Bins passieren

Bin Recutting: Suche nach ungewöhnlichen Mustern, Quantifizierung über summary-Params

// Template for a matrix. The dimensions are decided at run time
// This template makes a matrix of arbitrary dimensions
// There is no bounds checking
template <typename T>
class Matrix {
public:
// constructor with number of rows and columns
Matrix(int rows, int columns) {
// save number of rows and columns
this->rows = rows;
this->columns = columns;
// allocate memory
p = new T[rows * columns];
if (p == 0) {
// .. error message here: allocation failed
}
else {
// initialize all elements to zero
for (int i = 0; i < rows * columns; i++) {
p[i] = 0;
}
}
}
// get number of rows
int nrows() const {
return rows;
}
// get number of columns
int ncols() const {
return columns;
}
// destructor
~Matrix() {
if (p) delete[] p; // free the memory
}
// Operator [] gives a pointer to row number r.
// A second [] with the column number gives a single element
T * operator[] (int r) {
// no bounds check
return p + r * columns;
}
protected:
int rows; // number of rows
int columns; // number of columns
T * p; // pointer to memory
};
105
// ...
// Example of use:
// Make a matrix of doubles with 8 rows and 10 columns
Matrix<double> mat(8,10);
// Put a value in row 3, column 5
mat[3][5] = 12.34;
// Print out the matrix
for (int r = 0; r < mat.nrows(); r++) {
for (int c = 0; c < mat.ncols(); c++) {
printf("%5.2f ", mat[r][c]);
}
printf("\n");
}